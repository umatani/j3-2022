<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<html> <head>
<!-- (C)2012 K.Yanai (UEC) -->
<meta name="robots" content="noindex,nofellow">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=UTF-8">
<link href="https://fonts.googleapis.com/css?family=Lato:400,700|Noto+Sans+JP:400,700" rel="stylesheet">
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="../oop-new.css" type="text/css">

<script type="text/javascript" src="../ans.js"></script>

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushCpp.js"></script>
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreDefault2.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeDefault2.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
     SyntaxHighlighter.all()
</script>

<title>J3課題 第2回目</title>
</head>

<body>
<h1>J3課題 (第2回目)</h1>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

<h2>SwingライブラリによるGUIプログラミング (1)</h2>

<!--<P>
<a href="code/2code.zip" style="font-size:x-large; font-weight: bold;">今日の全サンプルコード</a><BR>
右クリックでダウンロードして，
</p>
<pre class="ref">
unzip 2code.zip
cd 2
./make_sample
</pre>
<P>
で実行してみてください．
コンパイルも，実行も全自動で行われます．
</p>-->

<h3>GUIプログラミング</h3>

<p>
前回はクラスとオブジェクトの説明で，C言語と同様に文字だけの表示でしたが，今回はいよいよJavaでGraphical User Interface (GUI)を扱う方法について説明します．
</p>

<p>Graphical User Interface (GUI)とは，ウィンドウやボタンなどのように画面に絵が表示され，それを使って操作を行う仕組みのことです．皆さんが使っているWindowsなどのソフトは，すべてGUIプログラムですね．一方，<code>javac</code>コマンドのようなターミナルから実行して出力が文字だけのプログラムは，Character-based User Interface (CUI)プログラムと呼ばれます．今までは，CUIプログラミングをずっと行なってきたということになります．さあ，ここからはGUIプログラミングです！
</p>

<p>
GUIのプログラムには，ボタン，スライダー，ラジオボタン，スライダー，メニューバーなど様々な部品が使われます．それらのGUI部品を組み合わせていくことによって自由に画面を設計して，GUIプログラムを構築することが可能です．GUI部品の集めたものをツールキットと呼んでいます．なお，GUI部品は自分で作ることも可能で，作り方についても次回以降説明します．まずは，すでに用意されている部品の使い方をマスターしましょう．
</p>

<p>
JavaのGUIのツールキットにはいろいろなものがありますが，Javaに標準で付属しているGUIツールキットには，以下の2種類があります．
</p>

<ul>
<li><a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/package-summary.html">AWT (Abstract Window Toolkit)</a></li>
<li><a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/package-summary.html">Swing</a></li>
</ul>
<p>
AWTは最初のJavaのバージョンである1.0から存在したツールキットです．一方，Swingはバージョン1.2になってから追加されたAWTを拡張したツールキットです．本演習では，Swingを主に使いますが，まず最初にAWTについても少しだけ触れてみます．
</p>

<h3>AWTプログラミング</h3>

<p>
まず最初は昔からあるAWTの使い方をみてみましょう．
</p>

<p>
AWTの一番基本的なプログラムは次のようになります．
</p>

<pre class="brush: java">
import java.awt.*;

class AWTFrame {
  public static void main(String[] args) {
    Frame f = new Frame("AWT Frame");
    f.setSize(300, 200);
    f.setVisible(true);
  }
}
</pre>

<p>
タイトルが付いている独立したウィンドウをAWTではフレーム(frame)と呼びます．
</p>

<p>
まず，
</p>

<pre class="ref">
Frame f = new Frame("AWT Frame");
</pre>

<p>
で，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/Frame.html"><tt>Frame</tt></a>オブジェクトを1つ作ります．フレームオブジェクトを作るときに指定した<code>"AWT Frame"</code>はウィンドウのタイトルに表示される文字列です．
</p>

<p>
次に，作ったフレームオブジェクトの<code>setSize</code>メソッドを呼び出します．
</p>
<pre class="ref">
f.setSize(300, 200);
</pre>

<p>
<code>setSize</code>メソッドが呼び出されると，フレームオブジェクトは自分の大きさを引数で指定された大きさにします．ここでは，横300ピクセル，縦200ピクセルにしています．
</p>

<p>
なお，<code>setSize</code>はフレームの大きさだけを指定しているので，フレームは画面中のどこに表示されるか分かりません．一般的には左上に表示されることが多いと思います．<code>setSize</code>メソッドの代わりに<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/Window.html#setBounds-int-int-int-int-"><tt>setBounds</tt></a>メソッドを用いると，画面中での表示位置も同時に指定できます．次の例では，画面上の左上を原点として(100,100)の位置を表示位置として，フレームのサイズを300x200にセットしています．

<pre class="ref">
f.setBounds(100, 100, 300, 200);
</pre>

<p>
最後に，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/Component.html#setVisible-boolean-"><tt>setVisible</tt></a>メソッドを引数<code>true</code>で呼び出すことによって，フレームオブジェクトは実際に画面にウィンドウを表示します．
</p>

<pre class="ref">
f.setVisible(true);
</pre>

<p>
この<code>setVisible</code>メソッドを呼び出さないと画面には何も表示されませんので注意してください．
</p>

<p>
結局，上のプログラムを実行すると画面にウィンドウが表示されます．
</p>

<p>
実行してみると，通常のCUIのプログラムと異なり，一度フレームが表示されると，プログラムの実行が終了しないでそのままの状態になることに気づくと思います．フレームが表示されたということは<code>setVisible</code>が実行されており，<code>main</code>メソッドの中身がすべて実行されたことになるのですが，終了はしません．これは，GUIプログラムが入力待ち(イベント待ち)状態になっているからです．一般的にGUIプログラムでは，画面が表示されるとユーザの入力待ちとなります．
</p>

<p>
このプログラムはフレームを表示しただけなので，フレームをクリックしても何も起こりません．ユーザの入力に対して，何か反応するプログラムを作っていくことが，GUIプログラミングとなります．なお，このプログラムを終了するには，ターミナルで <kbd>Ctrl+C</kbd> を押して下さい．フレームの上部の <kbd>×</kbd> ボタンを押してもフレームは消えますが，プログラム自体の実行は終了しません．
</p>

<p>
なお，1行目はAWTのライブラリを利用するために必要な記述ですので忘れないようにしましょう．とりあえず，C言語での<code>#include</code>と同じ様なものであると理解しておいて構いません．
</p>

<h3>Swingプログラミング</h3>

<p>
では次に，より高機能なSwingを使ってみます．スライダーやツールバーなどGUI部品が大幅に追加され，さらにウィンドウの見た目を自由に変更できるなど，機能が大幅に強化されています．これ以降はAWTは使いませんので，以下のSwingの使い方の基本を覚えましょう．
</p>

<p>
先ほどのAWTのサンプルプログラムと同じ動作をするプログラムをSwingを使って実現すると次のようになります．
</p>

<pre class="brush: java tab-size: 8">
import javax.swing.*;
import java.awt.*;

class SwingFrame {
  public static void main(String[] args) {
    JFrame f = new JFrame("Swing Frame");
    f.setSize(300, 200);
    f.setVisible(true);
  }
}
</pre>

<p>
ほとんど同じです．違いは，1行目に
</p>

<pre class="ref">
import javax.swing.*;
</pre>

<p>
が追加されたことと，<code>Frame</code>が<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JFrame.html"><tt>JFrame</tt></a>に変わったことだけです．先ほど説明した<code>setBounds</code>メソッドも同じように使えます．なお，<code>import</code>については，必ず2行目にある
</p>

<pre class="ref">
import java.awt.*;
</pre>

<p>
も書くようにして下さい．Swingは，一から作りなおしたライブラリではなくAWTを拡張したものであるため，AWTから完全に独立しておらず，AWTの機能を利用してつくられています．この2行の<code>import</code>文は，Swingを使う場合に必ず必要と覚えてしまいましょう．
</p>

<p>
Swingのすべての部品のクラス名は，<code>JFrame</code>クラスのようにJで始まる名前に統一されています．例えば，AWTには<code>Label</code>, <code>Panel</code>というクラス名の部品がありますが，Swingではそれぞれ<code>JLabel</code>，<code>JPanel</code>という名前になります．
</p>

<h3>実際のSwingプログラミング</h3>

<p>
先ほどは<code>JFrame</code>のオブジェクトを生成して，<code>JFrame</code>を画面上に表示してみました．しかしながら，実際のプログラミングでは，このようには記述せずに，<code>JFrame</code>を<em>継承(inheritance)</em>したクラスを作成して，利用することが一般的です．
</p>

<p>
継承の詳しい説明は次の章で行いますが，簡単に説明すると，すでにあるクラスを元に新しいクラスを作る方法です．新しいクラスを作るときに，差分だけを記述すれば良くなります．
</p>

<p>
<code>JFrame</code>クラスを継承した<code>NewFrame</code>クラスを定義するには次のようになります．
</p>

<pre class="ref">
class NewFrame extends JFrame {

  /* 追加されたフィールド */  

  public NewFrame() {
    /* コンストラクタの中身 */
  }

  /* 追加されたメソッド */  

}
</pre>

<p>
<code>JFrame</code>を継承したこの<code>NewFrame</code>クラスは，<code>JFrame</code>のすべてのフィールドとメソッドを保持して，さらに，追加されたフィールドと，追加されたメソッド，新たに記述されたコンストラクタをもつ新しいクラスとして定義されます．
</p>

<p>
Swingによるプログラム開発では，<code>JFrame</code>を継承したクラスを用意して，それに新しいメソッドを追加して機能拡張して，利用することが一般的です．では，この継承を使って，先ほどのサンプルを書きなおしてみます．
</p>

<pre class="brush: java">
import javax.swing.*;
import java.awt.*;

class NewFrame extends JFrame {
  public NewFrame() {
    this.setTitle("NewFrame");
    this.setSize(300, 200);
    this.setVisible(true);
  }

  public static void main(String[] args) {
    new NewFrame(); // NewFrameオブジェクトを生成します．生成すると，
                    // コンストラクタ内の処理が自動的に実行されます．
  }
}
</pre>

<p>
先ほどは<code>main</code>メソッドで<code>JFrame</code>オブジェクトを生成して，そのメソッドの<code>setSize</code>, <code>setVisible</code>を呼び出していたのですが，こちらの書き方では コンストラクタ内で，
</p>

<pre class="ref">
this.setsize(300, 200);
this.setVisible(true);
</pre>

<p>
と記述されています．この<code>this</code>は，自分自身のこと，つまり，<code>NewFrame</code>の自身のオブジェクトを表します．
</p>

<p>
じつは継承しているので，<code>JFrame</code>のメソッドは，<code>NewFrame</code>のメソッドでもあるのです．ですので，<code>NewFrame</code>クラス内のメソッドからは，<code>this</code>をつけて<code>JFrame</code>のメソッドを呼び出すことが可能になっています．なお，<code>this.setTitle</code>はフレームの名前を設定するメソッドです．<code>new JFrame(&lt;フレーム名文字列&gt;)</code>で，<code>JFrame</code>生成時に同時に設定していたのを，メソッドで設定するようにしました．
<!--(なお，この場合のthisは省略可能です．)-->
<!--<font color=red>(このあたりの詳しい話は，次回の説明を聞いてから理解すること言うことでか
まいません．今日はとりあえず，GUIプログラミングを体験してみましょう．)</font>-->
</p>

<p>
このようにコンストラクタに必要なことを書いておけば，<code>NewFrame</code>オブジェクトを生成するとコンストラクタ内の処理が自動的に実行されるので，<code>main</code>メソッドではなんと，
</p>

<pre class="ref">
new NewFrame();
</pre>

<p>
の一行だけで済んでしまいます．<code>NewFrame</code>オブジェクトを生成しますが，その後，特に参照する必要がないので，変数に代入することもしません．
</p>

<p>
このあとは，コンストラクタの中身を充実させて，色々な機能をもったリッチな<code>NewFrame</code>にして行きましょう！
</p>

<p>
ここで<code>NewFrame</code>に機能を一つ追加しておきましょう．デフォルトでは JavaのGUIでは，ウィンドウの左上の <kbd>×</kbd> 印をクリックしてウィンドウを閉じても，プログラムは終了しません．ウィンドウを閉じるとプログラムの動作が終了するようにするには，<code>JFrame</code>のメソッドの<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JFrame.html#setDefaultCloseOperation-int-"><tt>setDefaultCloseOperation</tt></a>の引数に<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JFrame.html#EXIT_ON_CLOSE"><tt>JFrame.EXIT_ON_CLOSE</tt></a>を指定して呼び出しておく必要があります．この<code>JFrame.EXIT_ON_CLOSE</code>というは，<code>JFrame</code>クラス内で定義された定数です．JavaにはC言語の様なグローバル変数はありませんので，必ずどこかのクラスの内部で<code>public static final &lt;型名(intやdoubleなど)&gt;</code>として定義して，利用する場合も<code>&lt;クラス名&gt;.</code>を定数名の前に付ける必要があります．具体的には，</p>

<pre class="ref">
public static final int EXIT_ON_CLOSE = 3;
</pre>

<p>
と定義されています．
<!-- <a href="http://docs.oracle.com/javase/jp/1.5.0/api/constant-values.html#javax.swing.JFrame.EXIT_ON_CLOSE">ここに</a>Javaのライブラリ内で定義された定数の一覧表があります． -->
</p>

<p>
<code>setVisible</code>の前に以下の1行を追加しましょう．これもおまじないだと思って必ず付けるようにしましょう．
</p>

<pre class="ref">
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
</pre>

<H3>GUI部品(ボタン，ラベル)の追加</H3>

<p>
ウィンドウが出るだけでは面白くありません．次に，ボタンを一つ追加してみましょう．次のようになります(灰色の部分が追加したところです)．
</p>

<pre class="brush: java; highlight: [8,9];">
import javax.swing.*;
import java.awt.*;

class ButtonFrame extends JFrame {
  public ButtonFrame() {
    this.setSize(300, 200);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    JButton b = new JButton("OK");
    this.add(b, BorderLayout.SOUTH);
    this.setVisible(true);
  }

  public static void main(String[] args) {
    new ButtonFrame();
  }
}
</pre>

<p>
<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JButton.html"><tt>JButton</tt></a>オブジェクトをフレームに追加してみました．
</p>

<p>
灰色でハイライト表示してある箇所の最初の行が，<code>JButton</code>オブジェクトの生成です．
</p>

<pre class="ref">
JButton b = new JButton("OK");
</pre>

<p>
<code>JFrame</code>オブジェクトの生成とまったく同じですね．そして，次の行で，<code>JFrame</code>のメソッドの<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/Container.html#add-java.awt.Component-int-"><tt>add</tt></a>メソッドで，<code>JFrame</code>オブジェクトに対して，ボタンオブジェクトを貼り付けています．
</p>

<!--
<p>
ただし，実際には，フレームに直接ボタンを追加したのではなくて，
JFrameオブジェクトのコンテンツ区画に対して部品を張付ける必要があります．
そのために，
f.<a href="http://docs.oracle.com/javase/jp/1.5.0/api/javax/swing/JFrame.html#getContentPane()">
getContentPane()</a>.add(..)となっています．</p>
<p>
ここでは，とりあえず，JFrame のオブジェクトに対しては，
add.getContentPane().add(..)で部品を張付けるというように覚えておいてくだ
さい．また，setLayout(..) を行う場合も同様にする必要があります
</p>
-->

<p>
<code>JFrame</code>に部品を追加する場合，デフォルトでは，上・下・左・右・中央（北・南・西・東・中央）の5箇所に追加できることになっています．上のプログラムでは，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/BorderLayout.html"><tt>BorderLayout</tt></a><tt>.SOUTH</tt>という定数で，下（南）を指定しています．他にも，<code>NORTH</code>，<code>EAST</code>，<code>WEST</code>，<code>CENTER</code>があります．位置関係は以下のようになります．なお，この定数のクラス名は<code>BorderLayout</code>となって，最初に<code>J</code>が付いていませんね．実は，<code>BorderLayout</code>クラスはAWTのクラスなのです．Swingでは，部品の配置に関するレイアウト関係のクラスは，昔からあったAWTのクラスがそのまま使われていますのです．他には色を表現する<code>Color</code>関係のクラスや，ボタンを押した時に処理を行うイベント処理関係のクラスもAWTのものを使います．
</p>

<img src="borderlayout.png" width=600/>

<div class="rep">
<h1>練習問題1 (提出不要)</h1>

<p>
実際に上のプログラム(Swing版)を動かしてみてください．また，プログラム中の<code>SOUTH</code>を<code>NORTH</code>，<code>WEST</code>，<code>EAST</code>，<code>CENTER</code>に変えてみてください．どうなりましたか？ また，ボタンやフレームに表示されるテキストもいろいろ変えてみてください．
</p>
</div>

<p>
では次に，<code>JButton</code>以外にもう一つ部品を紹介しましょう．
</p>

<p>
<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JLabel.html"><tt>JLabel</tt></a>を使ってみましょう．<code>JLabel</code>は文字を表示するだけの部品で表示専用です．<code>JButton</code>は実はボタンを押すと何か動作をさせることが可能(後で方法を説明します)ですが，<code>JLabel</code>はただ表示するだけです．ただし，一度表示した後に動的に表示する文字を変更することは可能です．これを利用して，練習問題でおみくじプログラムを作ってもらいます．
</p>

<pre class="brush: java; highlight: [10,11];">
import javax.swing.*;
import java.awt.*;

class LabelFrame extends JFrame {
  public LabelFrame() {
    this.setSize(300, 200);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    JButton b = new JButton("OK");
    this.add(b, BorderLayout.SOUTH);
    JLabel l = new JLabel("JLabel");
    this.add(l, BorderLayout.CENTER);
    this.setVisible(true);
  }

  public static void main(String[] args) {
    new LabelFrame();
  }
}
</pre>

<p>
これだと，<code>JLabel</code>の文字が左寄せで表示されてしまいます．センタリングしたいときは，
</p>

<pre class="ref">
JLabel l = new JLabel("JLabel", JLabel.CENTER);
</pre>

<p>
とします．他に，<code>JLabel.LEFT</code>，<code>JLabel.RIGHT</code>が指定できます．
</p>

<p>
では，文字サイズを変えるのはどうすればいいでしょう．<code>JLabel</code>のメソッドを使うこともできますが，もっと簡単な方法が<code>JLabel</code>にはあるのです．なんと，HTMLを表示することができるのです．(HTMLを用いない，Java本来のメソッドによる方法は<a href="faq2.html#font">FAQ</a>に書きました．)
</p>

<p>
例えば，次のように<code>JLabel</code>オブジェクト生成の行を変更してみてください．(長いので文字列を2行に分けて結合しています．HTML中のクォーテーションは，シングルクォーテーションを使うことに注意して下さい．)
</p>

<pre class="ref">
JLabel l =
  new JLabel("&lt;html>&lt;span style='font-size:36pt; color:blue; " 
  + "background-color:yellow;'>JLabel&lt/span>&lt;/html>", JLabel.CENTER);
</pre>

<img src="JLabel.png" width=600/>

<p>
文字列の<code>&lt;html&gt;</code>と<code>&lt;/html&gt;</code>で囲まれた部分はHTMLとして解釈され，表示されます．HTMLはいろいろあり過ぎて，ここでは説明しきれません．興味のある人は，<a href="http://www.htmq.com/">HTMLクイックリファレンス</a>やGoogleで検索するなどして，各自調べてみてください．ただし，すべてのHTMLに対応している訳ではなさそうです．
</p>

<p>
<a href="lion.jpg">ライオン画像</a>を右クリックでダウンロードして下さい．画像表示のHTMLタグを使って，
</p>

<pre class="ref">
JLabel l = new JLabel("&lt;html&gt;&lt;img src='file:lion.jpg' "
             + "width='100' height='100'/&gt;&lt;/html&gt;", JLabel.CENTER);
</pre> <!-- " -->

<img src="JLabel2.png" width=600/>

<p>
のように画像も含められます．これは，簡単ですね．ネットに繋がっていれば，<code>file:lion.jpg</code>の代わりに，<code>http://mm.cs.uec.ac.jp/lion.jpg</code>のように画像ファイルのURLを指定して表示することも可能です．
</p>

<div class="rep">
<h1>練習問題2 (提出不要)</h1>
<p>
<code>LabelFrame</code>のプログラムを改良して，様々な大きさ，色の文字を表示してみてください．使っていない<code>NORTH</code>，<code>WEST</code>，<code>EAST</code>にも文字や写真を入れてみましょう．
</p>
</div>

<h3>Swing の GUI部品 </h3>

<p>
先ほどは，SwingのGUI部品として<code>JButton</code>を使ってみましたが，他にもSwingにはたくさんのGUI部品があります．
</p>

<dl>
<dt><code>JDialog</code>*</dt><dd>一時的に表示されるウィンドウ</dd>
<dt><code>JFrame</code>*</dt><dd>タイトル付きの普通のウィンドウ</dd>
<dt><code>JButton</code>*</dt><dd>ボタン．**画像を埋め込むこともできる</dd>
<dt><code>JToggleButton</code>*</dt><dd>ON/OFFの状態を持ったボタン</dd>
<dt><code>JCheckBox</code>*</dt><dd>複数選択できるチェックボックス</dd>
<dt><code>JRadioButton</code>*</dt><dd>1つだけ選択できるチェックボックス</dd>
<dt><code>JColorChooser</code>**</dt><dd>色を選択するダイアログ</dd>
<dt><code>JComboBox</code>*</dt><dd>複数選択できるリストボックス</dd>
<dt><code>JFileChooser</code>*</dt><dd>ファイルを選択するダイアログ</dd>
<dt><code>JLabel</code>*</dt><dd>文字列を表示するラベル．**画像も表示できる</dd>
<dt><code>JList</code>*</dt><dd>リストボックス</dd>
<dt><code>JOptionPane</code>**</dt><dd>ダイアログを作成するための入れ物</dd>
<dt><code>JPanel</code>*</dt><dd>部品をいれる入れ物</dd>
<dt><code>JScrollBar</code>*</dt><dd>スクロールバー</dd>
<dt><code>JInternalFrame</code>**</dt><dd>内部フレーム</dd>
<dt><code>JLayeredPane</code>**</dt><dd>層状の入れ物(ぺイン)</dd>
<dt><code>JDesktopPane</code>**</dt><dd>内部フレーム用のぺイン</dd>
<dt><code>JPopupMenu</code>**</dt><dd>ポップアップメニュー</dd>
<dt><code>JProgressBar</code>**</dt><dd>数値を表示するバー</dd>
<dt><code>JScrollPane</code>*</dt><dd>スクロールバー付のぺイン</dd>
<dt><code>JSplitPane</code>**</dt><dd>分割ぺイン</dd>
<dt><code>JTabbedPane</code>**</dt><dd>タブ付ぺイン</dd>
<dt><code>JSlider</code>**</dt><dd>スライダー</dd>
<dt><code>JTable</code>**</dt><dd>表を作成</dd>
<dt><code>JToolBar</code>**</dt><dd>ツールバー</dd>
<dt><code>JToolTip</code>**</dt><dd>部品の上にマウスポインタが来た時に説明を表示</dd>
<dt><code>JTree</code>**</dt><dd>データをツリー状に表示</dd>
<dt><code>JEditorPane</code>**</dt><dd>テキストを編集するための部品</dd>
<dt><code>JTextArea</code>*</dt><dd>複数行の入力</dd>
<dt><code>JTextField</code>*</dt><dd>1行のテキスト入力</dd>
<dt><code>JPasswordField</code>**</dt><dd>パスワード入力</dd>
</dl>   

<p>
<b>*</b>はAWTにも同等のクラスがある部品，<b>**</b>はSwingで新たに追加された部品です．とても多くの部品があることが分かると思います．
</p>

<p>
とても多くて全ては説明しきれませんので，参考になるWebページを紹介しておきます．
</p>

<ul>
<li>
<a href="http://www.javadrive.jp/tutorial/">【Swingを使ってみよう -Java GUIプログラミング】</a>
<li>
<a href="http://www.tohoho-web.com/java/swing.htm">【Swingとは -とほほのJava入門】</a>
</ul>

<div class="panel panel-warning">
<div class="panel-heading"><b>注意</b></div>
<div class="panel-body">
<p>
外部のWebページや，少し古い本ではフレームオブジェクトに部品を貼り付けるときに，<code>getContentPane()</code>メソッドが使われていることがありますが，これは Javaバージョン1.5から不要になりました．そのまま付けたままコンパイルして実行しても結果は，付けない場合と同じですので，昔の名残りだと思って無視して下さい．つまり，以下の2つの動作は全く同じになります．
</p>

<pre class="ref">
this.add(b, BorderLayour.SOUTH);
</pre>
<pre class="ref">
this.getContentPane().add(b, BorderLayour.SOUTH);
</pre>

</div>
</div>

<H3>レイアウトの変更</H3>

<p>
今までは部品を置く場所が<code>NORTH</code>，<code>SOUTH</code>，<code>EAST</code>，<code>WEST</code>，<code>CENTER</code>の5つしかなかったので，最大5個までしか配置できませんでした．これでは，実用的なアプリケーションを作ることは困難です．
</p>

<p>
Swingでは，レイアウトマネージャという仕組みで部品を適切な位置に自動配置します．レイアウトマネージャには何種類かあって，何も指定しないと<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/BorderLayout.html"><tt>BorderLayout</tt></a>というレイアウトマネージャになっています．<code>BorderLayout</code>は，上下左右と中央に部品を配置するというレイアウトマネージャです．これは，すでに上で試してみました．
</p>

<p>
ここでは，別の <a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/GridLayout.html"><tt>GridLayout</tt></a>というレイアウトマネージャを使ってみます．<code>GridLayout</code>は，部品を同じ大きさの格子に並べるというものです．追加した順に，左から右，上から下に並べていきます．
</p>

<p>
利用するには，<code>JFrame</code>に部品を<code>add</code>する前に以下のように<code>GridLayout</code>を指定します．
</p>

<pre class="ref">
this.setLayout(new GridLayout(3, 2));
</pre>

<p>
<code>GridLayout</code>を作るときに，縦，横の格子の個数を指定します．縦，横の順番なので注意しましょう．
このプログラムでは，縦3個，横2個と指定しています．(どちらか一方を0にすることができます．そうすると，指定しなかったことになり，追加した部品の個数から計算されます．)
</p>

<p>
では，ボタンを6個配置してみましょう．一々書くのは面倒なので，6回forループで繰り返してみます．なお，<code>&lt;数値型変数&gt; + ""</code>で文字型に自動変換されますので，それを利用してボタンの文字列を指定しています．
</p>

<pre class="brush: java">
import javax.swing.*;
import java.awt.*;

class GridFrame extends JFrame {
  public GridFrame() {
    this.setSize(300, 200);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setLayout(new GridLayout(3, 2));
    for (int i = 1; i <= 6; i++)
      this.add(new JButton(i + ""));
    this.setVisible(true);
  }

  public static void main(String[] args) {
    new GridFrame();
  }
}
</pre>

<img src="gridlayout.png" width=600/>

<p>
他に，<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/BoxLayout.html"><tt>BoxLayout</tt></a>，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/CardLayout.html"><tt>CardLayout</tt></a>，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/FlowLayout.html"><tt>FlowLayout</tt></a>，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/GridBagLayout.html"><tt>GridBagLayout</tt></a>などがあります．
</p>

<div class="rep">
<h1>練習問題3 (提出不要) </h1>
<p>
<code>GridFrame</code>のプログラムを改良して，グリッドのサイズを自由に変更して，様々な大きさ，色の文字を表示してみてください．
</p>
</div>

<h3>ボタンを押した時の動作</h3>

<p>
上のプログラムでボタンを表示しました．そのボタンを押すことはできましたが，押しても何も起きませんでした．何も起きないとつまらないので，ボタンを押すとメッセージが表示される例題を作ってみましょう．
</p>

<p>
次のようになります．
</p>

<pre class="brush: java; highlight: [3,5,11,15,16,17];">
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

class HelloFrame extends JFrame implements ActionListener { 
  public HelloFrame() {
    this.setSize(300, 200);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    JButton b = new JButton("Hello");
    this.add(b, BorderLayout.SOUTH);
    b.addActionListener(this);
    this.setVisible(true);
  }

  public void actionPerformed(ActionEvent ev) {
    System.out.println("Hello");
  }

  public static void main(String[] args) {
    new HelloFrame();
  }
}
</pre>

<p>
<code>JButton</code>を押した，などのようなGUI画面に対するユーザからの入力を処理するこ
とを<em>イベント処理(event handling)</em>と言います．GUIプログラミングの動作は，イベントを処
理することによって行われていきます．こうしたプログラミングのスタイルを
<em>イベント駆動プログラミング(event-driven programming)</em>と言います．
</p>

<p>
Swingでは，イベント処理には AWTのイベント処理機能を使いますので，
</p>

<pre class="ref">
import java.awt.event.*;
</pre>

<p>
の一文を3つ目の<code>import</code>文として追加することが必要ですので，忘れないようにしましょう．
</p>

<p>
<code>JButton</code>は，押されるとあらかじめその<code>JButton</code>に登録しておいたオブジェクトの<code>actionPerformed</code>というメソッドを実行することになっています．
</p>

<p>
登録は，<code>JButton</code>の<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/AbstractButton.html#addActionListener-java.awt.event.ActionListener-"><tt>addActionListener</tt></a>メソッドで行ないます．上のプログラムでは，ハイライト行の3行目で登録しています．
</p>

<p>
<code>addActionListener</code>の引数は<code>this</code>になっています．<code>this</code>は自分自身という意味で，<code>HelloFrame</code>オブジェクトのことになります．ということは，<code>JButton</code>を押すと，<code>HelloFrame</code>の<code>actionPerformed</code>が呼び出されることになります．<code>actionPerformed</code>はユーザが呼び出すのではなく，Swingライブラリの中から<code>JButton</code>が押される度に自動的に呼び出されます．なお，<code>actionPerformed</code>メソッドの関数名と引数の型は，
</p>

<pre class="ref">
public void actionPerformed(ActionEvent ev) 
</pre>

<p>
と決まっていますので，これ以外に変更するとボタンが押されても呼び出されなくなりますので，注意して下さい．
</p>

<p>
実は，<code>addActionListener</code>で登録できるオブジェクトは何でも言いわけでなくて，クラス宣言の後に<code>implements ActionListener</code> が付いている必要があります．これは，<em>インタフェース(interface)</em>というものですが，次の章で詳しく説明します．
</p>

<div class="panel panel-info">
<div class="panel-heading"><b>補足</b></div>
<div class="panel-body">
インタフェースは，それが<em>実装(implement)</em>されたクラスが必ず持っている必要のあるメソッド名(返り値の型，引数の型も含む)を規定する仕組みです．規定するのは，名前と型だけでメソッドの中身はユーザが自由に記述できます．実は，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/event/ActionListener.html"><tt>ActionListener</tt></a>というのはJavaのシステムに用意されているインタフェースの一つで，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/event/ActionListener.html#actionPerformed-java.awt.event.ActionEvent-"><tt>actionPerformed</tt></a>メソッドが一つだけ記述されています．
</p>
</div>
</div>

<p name="HelloLabel">
さあ，おみくじプログラムまであと一歩です．上記の<code>HelloFrame</code>だと，ボタンを押すと文字はターミナルに表示されます．これだとちょっとがっかりですね．では，フレーム内に表示させる方法をご説明します．
</p>

<p>
<code>JLabel</code>の中身を動的に変更できればいい訳です．文字列を<code>JLabel</code>にセットするには，<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/TextComponent.html#setText-java.lang.String-"><tt>setText</tt></a>メソッドを使います．これを使うと，以下のようになります．ポイントは，<code>JLabel</code>をフィールド変数にして，コンストラクタ以外の他のメソッド(<code>actionPerformed</code>)からも参照できるようにすることです．
</p>

<pre class="brush: java; highlight: [6,13,14,19];">
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

class HelloFrame extends JFrame implements ActionListener { 
  private JLabel label;

  public HelloFrame() {
    this.setSize(300, 200);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    JButton b = new JButton("Hello");
    this.add(b, BorderLayout.SOUTH);
    label = new JLabel(" ", JLabel.CENTER);
    this.add(label, BorderLayout.CENTER);
    b.addActionListener(this);
    this.setVisible(true);
  }
  public void actionPerformed(ActionEvent ev) {
    label.setText("Hello !");
  }
  public static void main(String[] args) {
    new HelloFrame();
  }
}
</pre>

<img src="hello.png" width=600/>

<p>
さあどうですか？フレームの真ん中に「Hello!」が表示されましたね．では，おみくじプログラムの課題に行きましょう！
</p>

<div class="rep">
<h1 name="4">練習問題4 (提出課題)</h1>

<p>
ボタンを押すとおみくじが引けるプログラムを作ってください．<code>HelloFrame</code>の<code>actionPerformed</code>メソッドの中身を書き換えるだけでOKです．
</p>

<p>
<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/lang/Math.html#random--"><tt>random()</tt></a>メソッドを用いると乱数を得ることができます．次のようにすると，変数<code>r</code>に0.0から1.0までの乱数が一つ得られます．
</p>

<pre class="ref">
double r = Math.random();
</pre>

<p>
この乱数を使って，ボタンを押すと3通り以上の異なる結果が表示されるGUI版のおみくじプログラムを作ってください．
</p>

<p>
例えば次のようにします(この通りである必要はまったくありません)．
</p>

<ul>
  <li>乱数の値が0.7より大きければ good
  <li>乱数の値が0.2より大きく，0.7以下ならば so so
  <li>乱数の値が0.2以下ならば bad
</ul>

<!--
<p>
good, so so, badのプリントは，
</p>
<pre class="ref">
  JLabel l=new JLabel("OMIKUJI");
  this.add(l,BorderLayout.SOUTH);
</pre><p>
として，<a href="http://docs.oracle.com/javase/jp/1.5.0/api/javax/swing/JLabel.html">JLabel</a>を
用いて表示領域を確保しておいて，
</p>-->
<p>
あとは，ボタンが押されるたびに呼ばれる<code>actionPerformed</code>の中で乱数を発生させて，その値に応じて，
</p>

<pre class="ref">
label.setText("good");
</pre>

<p>
などと<code>JLabel</code>のテキストを変更するだけです．もちろん，日本語でもかまいませんし，HTMLを使って文字の色，大きさを変えたり，文字の代わりに画像を表示してみてもOKです．また，実は<code>JButton</code>の表示文字も<code>setText</code>によって動的に変えることも可能ですし，<code>JButton</code>の文字をHTMLで修飾表示することも可能です．
</p>

<p>
では，楽しいおみくじプログラムにしてみてください．
</p>
<!--
<p>
ただし，HelloPrinter クラスは，HelloButton クラス中の
main関数のローカル変数l を参照できないので，</p>
<pre class="ref">
class HelloPrinter implements ActionListener {
  JLabel l;
  HelloPrinter(JLabel l0) { l=l0; }
  public void actionPerformed(ActionEvent ev) {
  ...
</pre><p>
とし，以下のようにHelloPrinter オブジェクト生成時に JLabel オブジェクトを渡して，参照出来るようにしてやる必要があります．</p>
<pre class="ref">
 HelloPrinter hp = new HelloPrinter(l);
</pre>-->
</div>

<h2>継承とインタフェース</h2>

<p>
前の章では GUIプログラミングで，Javaでの標準GUIツールキットであるSwingの基本的な使い方を学習しました．<code>JFrame</code>にGUI部品を追加していくことで，簡単にGUIプログラムが書けることが分かったと思います．
</p>

<p>
GUIプログラミングの説明の中で<em>継承</em>，<em>インタフェース</em>という新しい用語が出てきました．さらにそれに関連した<code>extends</code>や<code>implements</code>という新しい構文も出てきました．前の章ではGUIプログラミングが主題でしたので，これらの新しい用語はとりあえず置いておいて，GUI版おみくじプログラムを完成させましたが，今回は，オブジェクト指向プログラミングにおいて重要な概念である継承とインタフェースについて学んで行きましょう．
</p>

<h3>クラスについての復習</h3>

<p>
継承とインタフェースはクラスを定義するときに用いる考え方ですので，新しい内容の説明に入る前に，まず前々回のクラスの話の復習をしておきましょう．
</p>

<p>
前回作った<code>Student</code>クラスは以下のようになっていました．<code>class &lt;クラス名&gt;</code>で最初にクラス名を定義して，フィールド，コンストラクタ，メソッドからなる中身を記述します．
</p>

<pre class="ref">
class Student {
  // フィールド （private なので外部からアクセス不可）
  private String id;    // 学籍番号
  private String name;  // 名前
  private int grade;    // 成績
      
  // コンストラクタ  (オブジェクト生成時に値を初期化します)
  public Student(String i, String n, int g) {
    id = i; name = n; grade = g; 
  }

  // メソッド  (外部からは <オブジェクト変数名>.print() で呼び出せる)
  public void print() {
    System.out.println("ID   : " + id);  
    System.out.println("Name : " + name);
    System.out.println("Grade: " + grade);
  }
}    
</pre>

<p>
フィールドには，そのオブジェクト内で必要なデータを記憶するための変数を記述します．ここは，通常の変数型(プリミティブ型)の<code>int</code>，<code>double</code>などに加えて，オブジェクト型の変数も書くことができます．オブジェクト型の変数とは，オブジェクトの雛形であるクラスから生成したオブジェクトを記憶しておくための変数で，<code>String</code>や<code>JLabel</code>のようなJavaのライブラリに用意されているクラスの型の変数に加えて，<code>Student</code>のような自分で定義したクラスの型の変数が利用できます．
</p>

<p>
コンストラクタはメソッドの一種ですが，特殊なメソッドで，メソッド名は常にクラス名と同一で，通常のメソッドと違って値を返さないので，関数としての型は記述しません．<code>public &lt;クラス名&gt;(&lt;引数&gt;, ...)</code>のように書きます．
</p>

<p>
メソッドは，<code>&lt;オブジェクト変数名&gt;.&lt;メソッド名&gt;(...)</code>で呼び出すことができます．メソッドも<code>private</code>を付けることができますが，その場合は同じクラス内の他のメソッドからしか呼び出せなくなります．
</p>

<p>それでは，新しい内容に移りましょう．</p>

<h3>GUIプログラミングで使われていた継承</h3>

<p>
前の章では，以下のようなプログラムをSwingによるGUIプログラムのひな型として利用しました．
</p>

<pre class="ref">
import javax.swing.*;
import java.awt.*;

class NewFrame <font color=red>extends JFrame</font> {
  public NewFrame() {
    this.setTitle("NewFrame");
    this.setSize(300, 200);
    this.setVisible(true);
  }

  public static void main(String[] args) {
    new NewFrame(); 
  }
}
</pre>

<p>
このプログラムの中では継承が利用されています．<code>class NewFrame</code>の後の，
</p>

<pre class="ref">
extends JFrame
</pre>

<p>
が継承を使うという宣言になります．継承は「受け継ぐ」という意味ですが，Javaでは単に受け継ぐだけではなく，受け継いでさらに<em>拡張</em>することができます．そのため「拡張する」という意味の動詞extendの3人称単数系のextendsがJavaの構文として用いられます．
</p>

<pre class="ref">
class NewFrame extends JFrame {
</pre>

<p>
という記述は，「クラス<code>NewFrame</code>は<code>JFrame</code>を拡張して定義します」ということを表しています．<code>JFrame</code>はJavaの標準ライブラリのSwingに含まれるクラスで，<code>NewFrame</code>はこれを拡張した物になります．継承を使った場合，元のクラスは<em>親クラス</em>，新しく定義するクラスを<em>子クラス</em>と言います．
</p>

<p>
親クラスと子クラスの関係は，次のようになります．
</p>

<ul>
<li>子クラスは，親クラスのすべてのフィールドを持っています．ただし，親クラスの<code>private</code>フィールドには直接はアクセスできません．アクセスするには，親クラスで定義されたメソッドを利用する必要があります．</li>
<li>子クラスは，親クラスの<code>private</code>以外のすべてのメソッドを持っています．ただし，親クラスのコンストラクタは継承されません．コンストラクタは子クラスで独自に定義する必要があります．</li>
</ul>

<p>
つまり，<code>NewFrame</code>は，自分で定義している<code>main</code>メソッドに加え，<code>JFrame</code>の膨大なメソッドを併せ持ったクラスであるということです．また，<code>private</code>なため直接はアクセスできないフィールドも含めて，すべての<code>JFrame</code>のフィールドも受け継いでいます．
</p>

<p>
そのため，以下のように<code>this</code>で表現される自分自身のオブジェクトに対して，<code>setTitle</code>や<code>setSize</code>を呼び出して，フレームのタイトルやフレームサイズを設定することが可能です．この様に親クラスから受け継いだメソッドを呼び出すことによって，子クラスである<code>NewFrame</code>からは直接アクセス不可能な，親クラスで<code>private</code>になっているフィールドの値を変更することが可能になります．
</p>

<pre class="ref">
public NewFrame() {
  this.setTitle("NewFrame");
  this.setSize(300, 200);
  this.setVisible(true);
}
</pre>

<!--先ほど述べたように，「子クラスでは，親クラスのコンストラクタは継承されず，
独自に定義する必要がある」ため，上記の様にコンストラクタを-->

<h3>継承の例</h3>

<p>
<code>JFrame</code>を親クラスとする例では，親クラスが標準ライブラリのクラスでした．ここでは，親クラスも自分で定義して，それを継承した子クラスを作ってみましょう．
</p>

<p>
継承を使うと，似たようなクラスがすでにある場合に，2つのクラスの差だけを記述するということが可能になります．
</p>

<p>
次のように書きます．
</p>

<pre class="ref">
class Oya {
  /* 中身は省略 */
}

class Kodomo extends Oya {
  /* 中身は省略 */
}
</pre>

<p>
クラス<code>Oya</code>という親クラスがあったときに，それを元にして，<code>Oya</code>クラスとの違いだけを書いて<code>Kodomo</code>クラスという子クラスを作ることができます．その場合，<code>Kodomo</code>クラスを定義するときに元になるクラスを<code>extends</code>で指定します．
</p>

<p>
元になるクラスである親クラスを<em>スーパークラス(super class)</em>，<code>extends</code>したクラスである子クラスを<em>サブクラス(sub class)</em>と呼ぶこともあります．
</p>

<p>
子クラスのオブジェクトは，親クラスのオブジェクトが持っている変数とメソッドをすべて持ち，さらに子クラスで追加された変数とメソッドも持ちます．例えば，
</p>

<pre class="brush: java">
class Oya {
  private int x = 0;
  public void setX(int x0) { x = x0; }
  public void printX() { 
    System.out.println("Oya: x = " + x); 
  }
  public void plusX() { 
    x++; 
  }
}

class Kodomo extends Oya {
  public void printX1() { 
    System.out.print("Kodomo: "); 
    printX();
  }
}

class Oyako {
  public static void main(String[] args) {
    Kodomo k = new Kodomo();  
    
    k.setX(10);  // Oyaのフィールドに値をセット
    k.printX();  // Oyaのメソッドを直接呼び出し
    k.printX1(); // Kodomoのメソッド経由で結果を表示

    k.plusX();   // +1
    k.plusX();   // +1
    k.printX();  // Oyaのメソッドを直接呼び出し
    k.printX1(); // Kodomoのメソッド経由で結果を表示
  }
}
</pre>

<p>
となっていた場合，<code>Kodomo</code>クラスのオブジェクトは，メソッド<code>printX1()</code>に加えて，<code>Oya</code>クラスで定義された変数<code>x</code>とメソッド<code>setX()</code>，<code>printX()</code>，<code>plusX()</code>も持っていることになります．
</p>

<p>
<code>Kodomo</code>クラスの<code>printX1</code>メソッドの中身を見てください．<code>printX()</code>が書かれていて，親のメソッドが呼ばれています．このように子クラスから，親クラスのメソッドを呼び出すことができます．
</p>

<p>
では，親クラスのフィールドの変数<code>x</code>は子クラスから参照したり値を変更したりできるでしょうか？上記の例の場合は，<code>private int x;</code>と，親の変数<code>x</code>が<code>private</code>になっていますので，子クラスと言えどもアクセスすることは許されていません．
</p>

<p>
この場合は，<code>private</code>の代わりに<code>protected</code>修飾子を使います．<code>protected</code>を付けることによって，次の例のように継承したクラスからは直接アクセスすることが可能となります．
</p>

<pre class="ref">
class Oya2 {
  <font color=red>protected</font> int x = 0;
  public void setX(int x0) { x = x0; }
  public void printX() { 
    System.out.println("Oya: x = " + x); 
  }
  public void plusX() { 
    x++; 
  }
}

class Kodomo2 extends Oya2 {
  public void printX1() { 
    System.out.print("Kodomo: "); 
    printX();
  }
  <font color=red>public void plusX10() { 
    x += 10;  // 親クラスのフィールドの変数xに直接アクセスできます．
  }</font>
}

class OyakoProtected {
  public static void main(String[] args) {
    Kodomo2 k = new Kodomo2();  
    
    k.setX(10);  // Oyaのフィールドに値をセット
    k.printX();  // Oyaのメソッドを直接呼び出し
    k.printX1(); // Kodomoのメソッド経由で結果を表示

    k.plusX();   // +1
    k.plusX10(); // +10
    k.printX();  // Oyaのメソッドを直接呼び出し
    k.printX1(); // Kodomoのメソッド経由で結果を表示
  }
}
</pre>

<div class="panel panel-info">
<div class="panel-heading"><b><tt>protected</tt>について</b></div>
<div class="panel-body">
<code>protected</code>は，継承したクラスからアクセス可能という意味ですが，厳密には「同一パッケージ内と，そのクラスを継承した子クラス内からアクセス可能」という意味になります．「同一パッケージ内」というのは，特にパッケージを意識しないでプログラミングするとすべてのクラスはパッケージなしのクラス，という扱いで，すべて「同一パッケージ内」になりますので，実質的には<code>protected</code>も<code>public</code>もあまり違いがありません．ですが，外部からはアクセスされたくないけど，子クラスからはアクセス可能にしたいということを明記するためにも，そのような場合は<code>public</code>よりも<code>protected</code>を使ったほうがいいでしょう．
</div>
</div>

<p>
では次に，子クラスで親クラスと同じメソッドを定義することはできるでしょうか？答えは「できる」です．その場合，親クラスのメソッドを子クラスで再定義したと言います．この場合，子クラスでは，再定義したメソッドが優先され，普通に呼び出すと子クラスで再定義したメソッドが使われます．
</p>

<p>
このような，子クラスによる親クラスのメソッドの再定義を<em>オーバーライド(override)</em> といいます．
</p>

<pre class="ref">
class Oya3 {
  protected int x = 0;
  public void setX(int x0) { x = x0; }
  public void printX() { 
    System.out.println("Oya: x = " + x); 
  }
  public void plusX() { 
    x++; 
  }
}

class Kodomo3 extends Oya3 {
  <font color=red>public void plusX() { // 親クラスのメソッドと同じメソッド名です．
    x += 10; 
  }</font>
}

class OyakoOverRide {
  public static void main(String[] args) {
    Kodomo3 k = new Kodomo3();  
    
    k.setX(10);  // Oyaのフィールドに値をセット
    k.printX();  // Oyaのメソッドを直接呼び出し

    k.plusX();   // +1と+10のどちらでしょう？
    k.printX();  // Oyaのメソッドを直接呼び出し
  }
}
</pre>

<p>
親クラスの同じメソッドもなくなったわけではなく隠れているだけなので，<code>super</code>を前に付ければ呼び出すことができます．例えば，先ほどのサンプルコードの<code>Kodomo3</code>クラスに<code>super.plusX();</code>を以下のように追加してみましょう．
</p>

<pre class="ref">
public void plusX() { 
  <font color=red>super.plusX();</font>
  x += 10; 
}
</pre>

<p>
<code>Oya3</code>クラスのメソッド<code>plusX()</code>は，<code>Kodomo3</code>クラスのメソッド<code>plusX()</code>によってオーバライドされていましたが，<code>Kodomo3</code>クラスのメソッド内からは <code>super.plusX();</code>とすることによって親クラスの<code>plusX()</code>を呼び出すことが可能となります．
</p>

<div class="rep">
<h1>練習問題5 (提出不要)</h1>
<p>
第1回目の<code>Student</code>クラスを継承を使って拡張してみましょう．
</p>

<p>
<input class="btn btn-primary" type="button" value="Studentクラスを表示" style="font-size:large;"
       onclick="
  if (document.getElementById('hide1').style.display == 'block') {
    document.getElementById('hide1').style.display='none';
  } else {
    document.getElementById('hide1').style.display='block';
  }
"/>
</p>

<div id="hide1" style="display: none;">
<pre class="ref">
class Student {
  private String id;    // 学籍番号
  private String name;  // 名前
  private int grade;    // 成績

  void print() {
    System.out.println("ID   : " + id);  
    System.out.println("Name : " + name);
    System.out.println("Grade: " + grade);
  }
  void setId(String i) {
    id = i;
  }
  void setName(String n) {
    name = n;
  }
  void setGrade(int g) {
    grade = g;
  }
}
</pre>
</div>

<p>
3年生になるとコース分けが行われます．また，4年生になるとコース内で研究室配属が行われ，指導教員が決まって所属研究室が決まります．そこで，3年生用の<code>Student3</code>クラスと，4年生用の<code>Student4</code>クラスを作ってみましょう．
</p>

<p>
<code>Student</code>クラスに，コース名
</p>

</p><pre class="ref">
private String course; // コース名
</pre><p>

<p>
を追加した<code>Student3</code>クラスをまず作りましょう．<code>setCourse</code>メソッドも<code>setId</code>メソッドと同じように追加してください．また，<code>print</code>メソッドをオーバライドして，<code>Student3</code>で追加された情報が表示されるように<code>print</code>メソッドを再定義してください．この時，<code>super</code>を使って親クラスの<code>print</code>も利用しましょう．
</p>

<p>
さらに，<code>Student3</code>クラスに所属研究室の指導教員名
</p>

<pre class="ref">
private String supervisor; // 指導教員名
</pre>

<p>
を追加した<code>Student4</code>クラスを作成して下さい．同様に<code>setSupervisor</code>メソッドを追加して，<code>print</code>メソッドをオーバライドし，<code>Student4</code>クラスで追加された情報が表示されるように<code>print</code>メソッドを再定義してください．
</p>

<p>
<code>main</code>メソッドは以下のように定義してください．「...」は適当な文字列や数値を指定してください．
</p>

<pre class="ref">
class Main {
  public static void main(String[] args) {
    Student3 st3 = new Student3();
    Student4 st4 = new Student4();

    st3.setId(...);
    st3.setName(...);
    st3.setGrade(...);
    st3.setCourse(...);

    st4.setId(...);
    st4.setName(...);
    st4.setGrade(...);
    st4.setCourse(...);
    st4.setSupervisor(...);

    System.out.println("[3年生]");
    st3.print();
    System.out.println("[4年生]");
    st4.print(); 
  }
}
</pre>

<p>
どうしても分からない人は，<input class="btn btn-success" type="button" value="ヒントボタン" style="font-size:large;"
       onclick="
  if (document.getElementById('hide2').style.display == 'block') {
    document.getElementById('hide2').style.display='none';
  } else {
    document.getElementById('hide2').style.display='block';
  }
"/>を押してみてください．<code>Student3</code>クラスの例が表示されますので，これを参考に <code>Student4</code>クラスを作ってみてください．ほとんど同じように書けば<code>Student4</code>クラスも完成します．
</p>

<div id="hide2" style="display: none;">
<pre class="ref">
<font color=red><b>// Student3 の解答です．自力で頑張りたい人はすぐに閉じましょう！</b></font>

class Student3 extends Student {
  private String course; // コース名

  void print() {
    super.print();  // superで１つ上の親クラスのprint()を呼び出す．
    System.out.println("Course: " + course); // コース名の表示
  }
  void setCourse(String c) {
    course = c;
  }
}
</pre>
</div>
</div>

<h3>継承とコンストラクタ</h3>

<p>
継承について説明したので，次にコンストラクタについて補足をしておきましょう．先ほどは以下のように説明しました．
</p>

<blockquote>
親クラスのコンストラクタは継承されません．引数付きのコンストラクタは子クラスで独自に定義する必要があります．引数なしのコンストラクタは継承されます．
</blockquote>

<p>
例えば，
</p>

<pre class="ref">
class A {
  private int x = 0;
  public A() {
    x = 10;
  }
  public A(int n) {
    x = n;
  }
  public void print() {
    System.out.println(x);
  }
}

class B extends A {
  // 省略
}
</pre>

<p>
というクラスがあったとして，<code>main</code>メソッドで
</p>

<pre class="ref">
B b = new B();
b.print();
</pre>

<p>
とすると，親クラスであるクラス<code>A</code>のコンストラクタ<code>A()</code>が呼ばれて，<code>10</code>と表示されます．
</p>

<p>
一方，引数付きのコンストラクタは継承されませんので，
</p>

<pre class="ref">
B b = new B(10);
</pre>

<p>
というプログラムを実行しようとすると，クラス<code>B</code>には引数付きのコンストラクタはないため，コンパイルエラーになります．
</p>

<p>
引数付きのコンストラクタは，次のように，継承したクラスでも定義する必要があります．
ただし，次の例のように，親クラスの<code>private</code>のフィールドには，子クラスから値を直接セットすることができません．そこで，子クラスのコンストラクタから，親クラスのコンストラクタを呼び出すための特殊な名前<code>super</code>が用意されています．これを使って，
</p>

<pre class="ref">
class A {
  private int x = 0;
  public A() {
    x = 10;
  }
  public A(int n) {
    x = n;
  }
  public void print() {
    System.out.println(x);
  }    
}
class B extends A {
  public B(int n) {
    super(n);  // 親クラスのコンストラクタをA(n)で呼び出す
    // ここにはBクラス特有の初期設定などを書く
  }
}
</pre>

<p>
と書くことができます．通常は，<code>super(n)</code>で親クラスのコンストラクタを呼び出した後に，子クラス特有の初期設定などを書きます．なお，この<code>super</code>は，コンストラクタの先頭でしか呼び出すことができませんので注意してください．例えば，
</p>

<pre class="ref">
class B extends A {
  private int y;
  public B(int n) {
    y = 0;
    super(n);  // 親クラスのコンストラクタをA(n)で呼び出す
  }
}
</pre>

<p>
とかくと，
</p>

<pre class="ref">
B.java:17: super の呼び出しはコンストラクタの先頭文でなければなりません。
      super(n);  // 親クラスのコンストラクタをA(n)で呼び出す
           ^
エラー 1 個
</pre>

<p>
というようにコンパイル時にエラーになってしまいます．
</p>

<p>
同様に，引数なしのコンストラクタでも，子クラス独自の初期設定を行いたい場合は，以下のように，引数ありの場合と同様に<code>super()</code>を使って，先に親のコンストラクタ
を呼び出してから，子クラス独自の設定を行います．
</p>

<pre class="ref">
class B extends A {
  private int y;
  public B() {
    super();  // 親クラスのコンストラクタをA()で呼び出す
    y = 0;
  }
}
</pre>

<p>
親クラスのコンストラクタ呼び出しの他に，<code>this(...)</code>とすることで，自分のクラスの別のコンストラクタ（別の引数を持つ）を呼び出すことも可能です．こちらもコンストラクタの先頭にしか書くことができません．
</p>

<p>
<code>this(...)</code>は例えばこんな風に使います．</p>
<pre class="ref">
class A {
  private int y;
  public A() { // コンストラクタ1
    this(0); // コンストラクタ2を呼び出す．xにデフォルト値0を指定．
  }
  public A(int x) { // コンストラクタ2
    this(x, 0); // コンストラクタ3を呼び出す．yにデフォルト値0を指定．
  }
  public A(int x, int n) { // コンストラクタ3
    super(x);
    y = n;
  }
}
</pre>

<p>
最も詳細に設定できる(つまり，引数の数が多い)コンストラクタを用意し，
他のコンストラクタは，引数にデフォルトの値を指定して，
最終的に一番細かく指定できるコンストラクタを呼び出すという方法です．
これはよく使われる方法です．
なお，このように同じ名前で引数だけ異なるメソッドを用意することを，
<em>オーバーロード(overload)</em>と言います．
Javaでは，メソッドの名前が同じでも引数の型や数が異なる場合は，異なる
メソッドとして扱います．オーバーロードは，コンストラクタだけでなく，
通常のメソッドでも可能です．子クラスで親クラスのメソッドを再定義する
オーバーライドと似ていますが，まったく別の仕組みですので注意しましょう．
</p>

<p>
ところで，コンストラクタを定義する際，必ず親クラスや自クラスの別のコンストラクタを呼び出さなければいけない決まりになっています．そのため，次のようなルールがあります．
</p>

<blockquote>
コンストラクタの先頭に<code>super(...)</code>か<code>this(...)</code>がない場合には，親クラスの引数なしコンストラクタを呼び出す<code>super()</code>が入っているものとする(暗黙の<code>super()</code>の実行)．
</blockquote>

<p>
ですので，<code>super()</code>は省略可能で，書いても書かなくても実際は同じなので，
</p>
<pre class="ref">
class B extends A {
  private int y;
  public B() {
    super();  // 親クラスのコンストラクタをA()で呼び出す
    y = 0;
  }
}
</pre>

は，

<pre class="ref">
class B extends A {
  private int y;
  public B() {
    // super()がなくても，親クラスのコンストラクタがA()で自動的に呼び出される
    y = 0;
  }
}
</pre>

<p>
と同じということになります．
</p>

<p>
また，引数なしのコンストラクタが自動的に呼び出されることを反映して，
次のようなルールもあります．
</p>

<blockquote>
コンストラクタが存在しないクラスには，自動的に引数なしコンストラクタが追加される．このコンストラクタは，親クラスの引数なしのコンストラクタを呼び出すだけで他には何もしない．
</blockquote>

<p>
ちなみに，先程「引数なしのコンストラクタは継承される」と説明していましたが，正確には，上のルールに従って自動的に追加された<b>自クラスの</b>引数なしコンストラクタが呼び出されています．呼び出されたコンストラクタ中で<code>super()</code>を呼び出すことしかしていないため，まるで親クラスの引数なしコンストラクタを継承しているかのように見えるだけです．
</p>

<div class="rep">
<h1>練習問題6 (提出不要)</h1>
<p>
継承関係のあるクラス<code>A</code>，<code>B</code>，<code>C</code>があり，それぞれ次のようなコンストラクタを持っているとします．各コンストラクタは，呼び出されるとメッセージを表示します．
</p>

<pre class="ref">
class A {
  public A() {
    System.out.println("A()");
  }
}

class B extends A {
  public B() {
    System.out.println("B()");
  }
  public B(int x) {
    System.out.println("B(int)");
  }
}

class C extends B {
  public C() {
    System.out.println("C()");
  }
  public C(int x) {
    super(x);
    System.out.println("C(int)");
  }
  public C(double x) {
    this();
    System.out.println("C(double)");
  }
}
</pre>

<p>
この時，<code>main</code>メソッドから次の文を実行すると，どのように表示されるでしょうか．その理由も説明してください．
</p>

<ol>
  <li><code>new C();</code></li>
  <li><code>new C(1);</code></li>
  <li><code>new C(1.0);</code></li>
</ol>
</div>

<h3>クラス階層</h3>

<p>
継承は何段にも重ねることが可能です．すなわち，あるクラスを継承したクラスを作り，そのクラスをさらに継承したクラスを作り……ということができます．
</p>

<p>
親クラスと子クラスの関係をつなげていくと，クラスの階層ができます．なお，Javaでは親クラスは1つしか指定できないので，必ず1つの子クラスは1つの親クラスを持つことになり，クラスの階層は木構造になります．
</p>

<p>
Javaの標準ライブラリは，すべて継承を利用して構築されているので，木構造で表現することが可能です．Javaでは，その階層の一番上に<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/lang/Object.html"><tt>Object</tt></a>というクラスがあります．
</p>

<p>
では，Javaの木構造を見てみましょう．<a href="https://docs.oracle.com/javase/jp/8/docs/api/overview-tree.html">これ</a>が木構造です．「木」をグラフィカルに表現している訳ではありませんが，代わりにインデント(字下げ)によって階層を表現しています．Javaの標準ライブラリは膨大で，下までスクロールするだけでも大変ですが，よくみるとすべてが<code>Object</code>クラスの下にあるのが分かると思います．
</p>

<p>
全部見ると膨大過ぎて階層構造が分からないので，1つのクラスに注目して階層構造を見てみましょう．オンラインマニュアルの各クラスの説明のページに，そのクラスのすべての祖先にあたる親クラスの階層構造が書かれています．例えば，<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JFrame.html"><tt>JFrame</tt>クラスのマニュアル</a>を見ると，その最初の部分に次のように<code>JFrame</code>クラスの祖先のクラスが書いてあります．(クラス名の前の，<code>java.lang</code>や<code>java.awt</code>などはパッケージ名を表します．詳しく知りたい人は下記の<a href="#package">【パッケージについて】</a>を読んでください．)
</p>

<pre class="ref">
java.lang.Object
   |
   +----java.awt.Component
           |
           +----java.awt.Container
                   |
                   +----java.awt.Window
                           |
                           +----java.awt.Frame
                                   |
                                   +---javax.swing.JFrame
</pre>

<p>
<code>JFrame</code>クラスの親はAWTの<code>Frame</code>クラスで，その親は<code>Window</code>クラスで，さらにその親は<code>Container</code>クラス，<code>Component</code>クラスで，一番上は<code>Object</code>クラスになります．
</p>

<p>
この様に，すべてのクラスは，その親を辿っていくと最後は<code>Object</code>クラスに到達します．
</p>

<div class="panel panel-info">
<div class="panel-heading"><b>階層構造の意味</b></div>
<div class="panel-body">
<p>
階層構造になっているのは，祖先のクラスの性質を子孫が利用するためです．上記の階層構造の場合は，どのように性質が引き継がれているか説明しましょう．
</p>

<p>
まずAWTのすべてのGUI部品が<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/Component.html"><tt>Component</tt></a>のサブクラスになっています．<code>Component</code>はAWT部品の基本的な性質を定義していて，部品の大きさを決める<code>setSize</code>や，表示状態をセットする<code>setVisible</code>などGUI部品クラスの基本的なメソッドが定義されています．
</p>

<p>
<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/Container.html"><tt>Container</tt></a>は，中に部品を入れることができる部品を定義しています．GUI部品を<code>add</code>することのできるGUI部品はすべて<code>Container</code>のサブクラスになっています．<code>Container</code>で中に部品を入れるメソッドは，<code>add(Component c)</code>というメソッドです．<code>add</code>の引数が<code>Component</code>になっているということは，<code>Component</code>およびそのサブクラスは部品として追加できるということになります．<code>Container</code>は<code>Component</code>のサブクラスですから，<code>Container</code>自身も<code>Container</code>に追加できることになります．これによって，<code>Container</code>の中に<code>Container</code>が入るという，入れ子の構造(再帰的データ構造)が可能になります．
</p>

<p>
SwingのGUI部品は，AWTの<code>Container</code>クラスを継承した<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JComponent.html"><tt>JComponent</tt></a>を継承しています．SwingのGUI部品は<code>Container</code>クラスを継承しているので，普通は行いませんが，AWTとSwingの部品を混ぜて使ったり，通常入れ物として使われない様な部品(例えばボタン)の中に部品を<code>add</code>したりも出来ます．
</p>
</div>
</div>

<p>
マニュアルを見てメソッドを探す時には，<code>JFrame</code>クラスは祖先のクラスのメソッドも使えるということに注意してください．祖先のクラスのメソッドを探すのを忘れてしまうことがよくありますので，注意しましょう．
</p>

<p>
例えば，<code>JFrame</code>のメソッドは，<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JFrame.html#method.summary"><tt>JFrame</tt>独自のメソッド</a>だけではなく，<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JFrame.html#methods.inherited.from.class.java.awt.Frame">すべての祖先のクラスのメソッド</a>も<code>JFrame</code>のメソッドになっています．</p>

<div class="panel panel-info" id="package">
<div class="panel-heading"><b>パッケージについて</b></div>
<div class="panel-body">

<p>
Javaには膨大なクラスライブラリがあるので，すべて異なるクラス名を付けなければいけないとすると，使ってない名前を探すのが大変になってきます．そこで，Javaでは<em>パッケージ(package)</em>という考え方を導入して，クラス名の衝突を防ぐとともに，クラスをパッケージにまとめて膨大なクラスの管理を容易にする工夫をしています．
</p>

<p>
Java内部では，<code>&lt;パッケージ名&gt;.&lt;クラス名&gt;</code>でクラスが管理されいて，同じクラス名でも パッケージ名が異なれば，異なるクラスと見なされます．<a href="https://docs.oracle.com/javase/jp/8/docs/api/overview-tree.html">クラス木構造のページ</a>の先頭に書いてある「パッケージ」とは，Javaがクラスを管理するためにつかうパッケージ名のことです．例えば，Swingのクラスは<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/package-tree.html"><tt>javax.swing</tt>パッケージ</a>に属していて，例えば，<code>JFrame</code>は内部的には<code>javax.swing.JFrame</code>という名前で管理されています．
</p>

<p>
Javaには<a href="http://docs.oracle.com/javase/jp/8/docs/api/overview-summary.html">多くのパッケージ</a>がありますが，最も良く使われる<a href="http://docs.oracle.com/javase/jp/8/docs/api/java/lang/package-tree.html"><tt>java.lang</tt>パッケージ</a>以外は，パッケージ内のクラスを利用するため<code>import</code>宣言が必要になります．実際には，<code>&lt;パッケージ名&gt;.&lt;クラス名&gt;</code>として利用することも可能ですが，いちいちパッケージ名を書くのは面倒なので，通常は<code>import</code>文を使います．
</p>

<pre class="ref">
import javax.swing.*;
import java.awt.*;
</pre>

<p>
という<code>import</code>宣言は，<code>javax.swing</code>パッケージの全クラス，<code>java.awt</code>パッケージの全クラスをパッケージ名の記述なしで利用するという宣言になります．<code>.*</code>はすべてのクラスと言う意味で，<code>import javax.swing.JFrame;</code>のようにクラス名を直接指定することも可能です．なお，標準の<code>java.lang</code>パッケージだけは，暗黙のうちに<code>import java.lang.*;</code> が宣言されていることになります．
</p>

<p>
パッケージは，クラスの継承関係とは独立していますので注意してください．クラスの祖先をたどっていくと色々なパッケージに属するクラスが表れるのはそのためです．
</p>
</div>
</div>

<p>
すべてのクラスは<code>Object</code>クラスの子孫クラスになっていると先程説明しました．実は，何も<code>extends</code>していないクラスも，Javaでは暗黙のうちに<code>Object</code>の子クラスになっています．つまり，
</p>

<pre class="ref">
class A {
  ...
}
</pre>

<p>
というのは，実は
</p>

<pre class="ref">
class A extends Object {
  ...
}
</pre>

<p>
と等価です．
</p>

<div class="rep">
<h1>練習問題7 (提出不要)</h1>

<p>
GUIプログラミングでは，Swingの次のようなメソッドを使いました．
</p>

<ul>
  <li><code>JFrame</code>の<code>add</code>(引数が2つの<code>add</code>)</li>
  <li><code>JFrame</code>の<code>setTitle</code></li>
  <li><code>JFrame</code>の<code>setVisible</code></li>
  <li><code>JLabel</code>の<code>setText</code></li>
  <li><code>JButton</code>の<code>addActionListener</code></li>
</ul>

<p>
これらのメソッドの大部分は，実際には親クラスで定義されたメソッドを使うことになります．
</p>

<p>
上記のメソッドは実際にはどのクラスで定義されたメソッドが使われるの
でしょうか？ 複数候補がある場合は，引数の型があっているメソッドで，
最も近い祖先のクラスのメソッドが使われますので注意してください．
このことを
<a href="http://docs.oracle.com/javase/jp/8/docs/api/javax/swing/package-summary.html">Swingのオンラインドキュメント</a>で調べてください．
</p>

<p>
さらに，<code>JLabel</code>と<code>JButton</code>の祖先クラスを<code>java.lang.Object</code>から順番にそれぞれ列挙してみてください．
</p>
</div>

<h3>インタフェース</h3>

<p>
インタフェースという仕組みは，<code>JButton</code>を押した時に何か動作を行わせるために利用しました．そのときのプログラムは以下のようなものでした．
</p>

<pre class="ref">
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

class HelloFrame extends JFrame <font color=red>implements ActionListener</font> { 
  public HelloFrame() {
    this.setSize(300, 200);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    JButton b = new JButton("Hello");
    this.add(b, BorderLayout.SOUTH);
    b.addActionListener(this);
    this.setVisible(true);
  }
  public void actionPerformed(ActionEvent ev) {
    System.out.println("Hello");
  }
  public static void main(String[] args) {
    new HelloFrame();
  }
}
</pre>

<p>
インタフェースを使うという宣言は<code>class HelloFrame extends JFrame</code>の後の
</p>

<pre class="ref">
implements ActionListener
</pre>

<p>
で行われています．<code>implements</code>の後の<code>ActionListener</code>は<em>インタフェース(interface)</em>と呼ばれます．一方，<code>implements</code>は，インタフェースを<em>実装(implementation)</em>するという意味になります．インタフェースにはクラスが必ず持っているメソッド名(返り値の型，引数の型も含む) が書かれてあり，それを実装するとは，そのインタフェースに書かれたメソッドを新しく定義するクラスに必ず持たせる，という意味になります．つまり，
</p>

<pre class="ref">
class HelloFrame implements ActionListener
</pre>

<p>
と書くと，<code>HelloFrame</code>は<code>ActionListener</code>インタフェースに書かれているメソッドを持っています，という意味になります．
</p>

<p>
インタフェースとクラスは一見似ているのですが，実際には大きく違います．クラスではフィールドやメソッドの中身を定義するが，インタフェースでは<b>メソッド名のみを宣言する</b>という点で異なります．C言語のプロトタイプ宣言に少し似ています．具体的には，
<a href="http://docs.oracle.com/javase/jp/8/docs/api/java/awt/event/ActionListener.html">ActionListenerインタフェース</a>は
</p>

<pre class="ref">
interface ActionListener {
  void actionPerformed(ActionEvent e);
}
</pre>

<p>
と定義されています．メソッドの中身は定義しないので，実際に書かれている内容はたったこれだけです．<code>void actionPerformed(ActionEvent e)</code>と書かれていますが，メソッドの中身は書かれておらず，単にメソッドの名前，返り値の型，引数の型が書かれているだけで，<code>{ /*メソッドの中身*/ }</code>の代わりにセミコロン(<code>;</code>)が最後に付いています．
</p>
  
<p>
なお，インタフェースで宣言されたメソッドは，すべて自動的に<code>public</code>になりますので，特に<code>public</code>と書く必要はありません．
</p>

<div class="panel panel-info">
<div class="panel-heading"><b>インタフェースでの定数の定義</b></div>
<div class="panel-body">
今回の演習では特に説明しませんが，インタフェースでは，定数を定義することもできます．詳しくは，「Java インタフェース 定数」みたいにネット検索してみてください．
</div>
</div>

<p>
この<code>ActionListener</code>を実装した<code>NewFrame</code>は，<code>actionPerformed</code>というメソッドを必ず持たなくてはいけません．持っていないとコンパイル時にエラーが出ます．例えば，<code>HelloFrame</code>で<code>actionPerformed</code>を削除してしまうと，次の様なエラーメッセージが出ます．このメッセージは，「インタフェース<code>ActionListener</code>中で宣言された中身の定義されていないメソッド<code>actionPerformed</code>が<code>HelloFrame</code>中でオーバーライドされていません」ということを注意していて，つまり「<code>actionPerformed</code>を<code>HelloFrame</code>中で定義しなさい」いうメッセージです．継承では親のメソッドが子クラスでは定義しなくてもそのまま使えましたが，このように実装では実装したクラスの方で必ずメソッドを定義してやる必要があります．
</p>

<p>
<pre class="ref">
HelloFrame.java:5: HelloFrame は abstract でなく、java.awt.event.ActionListener 内の abstract メソッド 
actionPerformed(java.awt.event.ActionEvent) をオーバーライドしません。
class HelloFrame extends JFrame implements ActionListener {
^
エラー 1 個
</pre>
<!--<p>
ちなみに，implementとは，動詞の場合，履行する，実行する，条件を満たす，などの意味
が辞書には載っていますが，「条件を満たす」がここでの implementの意味に相当します．
ActionListener に記述されている条件を class NewFrame が満たしているいうことになります．
extendsと同様に，
3人称単数系の「implements」がJavaの構文として用いられます．
プログラミングする時に「○○を実行するプログラムをインプリメントする」
というような使い方をしばしばしますが，これとは少し異なります．
</p>-->

<p>
では，インタフェースは一体どんなことに使えるのでしょうか？実は，インタフェースは，クラスと同様にインタフェース型の変数を定義することができます．インタフェース型の変数には，そのインタフェースを実装したオブジェクトを代入することができます．<code>JButton</code>クラスでは，このことをうまく利用して，押すと<code>actionPerformed</code>が呼ばれる仕組みを実現していました．
</p>

<p>
JButtonの<a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/AbstractButton.html#addActionListener-java.awt.event.ActionListener-"><tt>addActionListener</tt>メソッド</a>の引数の型を見てみてください．
</p>

<pre class="ref">
public void addActionListener(ActionListener l)
</pre>

<p>
となっていることから，<code>ActionListener</code>型であることが分かると思います．この<code>ActionListener</code>が先ほど説明したようにクラスではなく，インタフェースです．つまり，<code>addActionListener</code>の引数には，<code>ActionListener</code>インタフェースを実装したクラスのオブジェクトを渡す必要があるということになります．
</p>

<p>
<code>JButton</code>は，押されるとあらかじめ<code>JButton</code>に登録しておいたオブジェクトの<code>actionPerformed</code>という名前のメソッドを実行することになっています．
</p>

<p>
<code>actionPerformed</code>メソッドを持ったオブジェクトの登録が，<code>JButton</code>の<code>addActionListener</code>メソッドで行なわれていたわけです．<code>addActionListener</code>の引数は<code>ActionListener</code>型ですので，必ず<code>actionPerformed</code>メソッドを持っていることが保証されています．ですので，ボタンが押されたときに<code>JButton</code>の内部では安心して<code>actionPerformed</code>を呼び出すことができるのです．
</p>

<p>
もちろん，登録されたオブジェクトは<code>actionPerformed</code>以外のメソッドを持っていても構いませんが，オブジェクトを<code>ActionListener</code>型として扱っている<code>JButton</code>内部では，<code>actionPerformed</code>以外のメソッドは一切使用しませんし，関知しませんので，あってもなくても構わないことになります．
</p>

<img src="actionPerformed.png" width=600/>


<h3>インタフェースの例</h3>

<p>
次に，<code>ActionListener</code>以外のインタフェースの例を考えてみましょう．
</p>

<p>
例えば，写真を撮る<code>takePhoto</code>メソッドを考えましょう．写真を撮ることは，携帯電話でもデジカメでもビデオカメラでもできます．そこで，それらのクラスを<code>Cellular</code>，<code>Camera</code>，<code>VideoCam</code>とすると，それらはすべて<code>takePhoto</code>メソッドを持っていることになります．また，<code>Cellular</code>クラスは電話を掛ける<code>makeCall</code>メソッド，<code>VideoCam</code>クラスは動画を撮影する<code>recordMovie</code>メソッドをもっていることとします．
</p>

<p>
さて，写真を撮る道具(オブジェクト)が必要になったとします．その時には，オブジェクトが<code>makeCall</code>メソッドや<code>recordVideo</code>メソッドを持っているかどうかは問題ではありません．オブジェクトが<code>takePhoto</code>メソッドを持っていることだけが重要です．すなわち，写真を撮るにはそれぞれのオブジェクトの全公開メソッドの一部分だけが重要であり，残りのメソッドは違っていても構わないのです．
</p>

<p>
そこで，<code>takePhoto</code>という写真を撮影するのに不可欠なメソッドの部分集合に，「<code>Photo</code>インタフェース」という名前を付けることにします．そうすると，<code>Cellular</code>も<code>Camera</code>も<code>VideoCam</code>も「<code>Photo</code>インタフェースを持っている」ということができます．
</p>

<p>
写真を撮影するには，
</p>

<blockquote>
<code>Photo</code>インタフェースを持っている道具を用意すればよい
</blockquote>

<p>
ということになります．
</p>

<p> 
このように，Javaにはクラスの持つ公開メソッド集合の部分集合に名前を付けて使う仕組みが用意されています．それがインタフェース定義です．
</p> 

<p>
インタフェース定義は，クラス定義と同じように書きますが，メソッドの本体は書かずに宣言だけを書きます．例えば，<code>Photo</code>インタフェースならば，次のようになります．
</p>

<pre class="ref">
interface Photo {
  void takePhoto();
}
</pre>

<p>
インタフェースは，「クラスの持つ公開メソッドの部分集合」ですから，インタフェースで宣言したメソッドは，何も書いてなくても<code>public</code>だと見なされます．<code>public</code>と書いてももちろん構いません．
</p>

<p>
一方，あるクラスが，あるインタフェースを持つことは<code>implements</code>で宣言します．例えば，次のようになります．
</p>

<pre class="ref">
class Cellular implements Photo {
  public void makeCall() {
    System.out.println("携帯電話で電話を掛けました．");
  }
  public void takePhoto() {
    System.out.println("携帯電話で写真を撮りました．");
  }
}

class Camera implements Photo {
  public void takePhoto() {
    System.out.println("デジカメで写真を撮りました．");
  }
}

class VideoCam implements Photo {
  public void recordMovie() {
    System.out.println("ビデオカメラで動画を撮影しました．");
  }
  public void takePhoto() {
    System.out.println("ビデオカメラで写真を撮りました．");
  }
}
</pre>

<p>
<code>implements</code>で宣言することにより，<code>Camera</code>は写真撮影ができることが保証されます．同様に，<code>Cellular</code>や<code>VideoCam</code>も写真撮影が保証されます．
</p>

<p>
<code>implements Photo</code>と宣言すれば，そのクラスは<code>Photo</code>インタフェースに含まれるすべてのメソッドを持っていないといけません．<code>implements Photo</code>と宣言しているのに<code>takePhoto</code>メソッドがないと，先ほど述べたようにコンパイルエラーになります．
</p>

<p>
インタフェースは，クラスと同様にその型を持つ変数を宣言できます．例えば，<code>Photo</code>型の配列に<code>Photo</code>インタフェースを実装したオブジェクトを代入して，次々に<code>takePhoto</code>メソッドを呼び出すこともできます．
</p>

<pre class="ref">
Photo l[] = new Photo[3];

l[0] = new Cellular();
l[1] = new Camera();
l[2] = new VideoCam();

for(int i = 0; i < 3; i++)
  l[i].takePhoto();
</pre>

<p>
このように<code>Photo</code>型の変数には，<code>Photo</code>インタフェースを実装しているクラスのオブジェクトなら，どんなクラスのオブジェクトでも代入することができます．ただし，<code>Photo</code>型の変数にオブジェクトを代入した場合，そのオブジェクトは<code>Photo</code>型として扱われるので，
</p>

<pre class="ref">
l[0].takePhoto(); 
</pre>

<p>
はできますが，
</p>

<pre class="ref">
l[0].makeCall(); 
</pre>

<p>
はエラーになります．
</p>

<div class="alert alert-danger" role="alert">
  <span class="glyphicon glyphicon-warning-sign" aria-hidden="true"></span>
  <span class="sr-only">Warning:</span>
間違える人が多いですが，インタフェースはクラスではありませんのでオブジェクトは生成できません．オブジェクトを生成できるのはクラスだけです．インタフェースは必ず<code>implements</code>して使います．注意しましょう．
</p>

<pre class="ref">
<b><font color=red>できない例．このような書き方はエラーになります．</font></b>
Photo p = new Photo(); // Photoインタフェースのオブジェクトは生成できません．
</pre>
</div>


<div class="rep">
<h1>練習問題8 (提出不要)
</h1>

<p>
次のプログラムの中で，コンパイルエラーになる部分は何行目でしょうか？ 実行する前に予測してみてください（複数箇所あります）．また，それはなぜでしょうか？ 理由を説明してください．
</p>
<!-- 10-12, 17, 27 -->

<pre class="brush: java;">
interface A {
  public void f();
}

class B1 implements A {
  public void f() { }
  public void f1() { }
}

class B2 implements A {
  public void f1() { }
}

class C {
  public void g(A a1) {
    a1.f();
    a1.f1();
    g(a1);
  }
  public void h() {
    B1 b1 = new B1();
    b1.f();
    b1.f1();
    g(b1);
    A a2 = b1;
    a2.f();
    a2.f1();
    g(a2);
  }
}
</pre>
</div>


<div class="rep">
<h1>練習問題9 (提出不要ですが，ぜひやってみてください)
</h1>

<p>
先ほど例に挙げた<code>Photo</code>インタフェースとそれを実装した<code>Cellular</code>，<code>Camera</code>，<code>VideoCam</code>クラスに，同様に<code>Photo</code>インタフェースを実装した新しいクラス<code>iPhone</code>クラス(<code>Android</code>クラスでも可)を追加してください．さらに，<code>Photo</code>型のオブジェクトの集合を記録して，すべての<code>takePhoto</code>メソッドを実行する<code>Photographer</code>クラスを完成させてください．<code>Photo</code>型オブジェクトを追加するメソッドは<code>void add(Photo p)</code>，すべての登録<code>Photo</code>オブジェクトの<code>takePhoto</code>を呼び出すメソッドは<code>void takeAll()</code>としてください．
</p>

<p>
<code>iPhone</code>クラスと<code>Photographer</code>クラスが完成したら，<code>Photographer</code>オブジェクトを1つ生成し，4つのクラスのオブジェクトをランダムで合計20個生成し<code>add</code>メソッドで追加してください．追加が終わったら，<code>takePhoto</code>メソッドを呼び出してください．(乱数の生成はおみくじプログラムを参考にしてください．)
</p>

<p><code>Photographer</code>クラスのひな型を見たい人は<input class="btn btn-success" type="button" value="Photographerクラスのひな型を表示" style="font-size:large;"
       onclick="
  if (document.getElementById('hide3').style.display == 'block') {
    document.getElementById('hide3').style.display='none';
  } else {
    document.getElementById('hide3').style.display='block';
  }
"/>

を押してください(ヒントなしにできそうな人は，見ないで頑張ってみましょう)．
</p>

<div id="hide3" style="display: none;">
<pre class="ref">
// Photographer クラスのひな型です．
// iPhoneクラスは Cellularクラスなどを参考に自分で実装してください．

class Photographer {
  // final staticint は定数の定義です
  final static int MAX = 20;
 // オブジェクト生成時に初期化します
  private Photo camera[] = new Photo[MAX];
  // 現在の登録Photoオブジェクト数
  private int num = 0;

  public void add(Photo p) {
    if (num &gt;= MAX) return; // MAX以上は登録しない
    camera[num++] = p;
  }

  // すべてのtakePhotoの呼び出し
  public void takeAll() {
    for (int i = 0; i &lt; num; i++) {
      System.out.print("[" + (i + 1) + "] ");
      camera[i].takePhoto();
    }
  }

  public static void main(String[] args) {
    Photographer p = new Photographer();
    for(int i = 0; i &lt; MAX; i++) {
      // 乱数を生成させ，値によって
      // Celluar, iPhone, Camera, VideoCamera の1つを選択し，
      // p.add(new &lt;クラス名&gt;()); を実行してください．
    }
    p.takeAll();
  }
}
</pre>
</div>

<p>例えば，以下のような結果が出ます(一部のみ示します)．</p>

<pre class="ref">
[1] デジカメで写真を撮りました．
[2] ビデオカメラで写真を撮りました．
[3] iPhoneで写真を撮りました．
[4] 携帯電話で写真を撮りました．
[5] iPhoneで写真を撮りました．
...
</pre>

</div>

<p>
クラス定義では継承するクラスを1つしか指定できませんが，インタフェースはいくつでも実装することが出来ます．たとえば，動画が撮影できることを表すインタフェース<code>Movie</code>を定義したとすると，以下のようになります．
</p>

<pre class="ref">
interface Movie {
  void recordMovie();
}

class VideoCam implements Photo, Movie {
  public void recordMovie() {
  }
  public void takePhoto() {
  }
}
</pre>

<p>


<h3>親クラス(インタフェース)と子クラスのメソッド集合の包含関係</h3>

<p>
継承関係にある親クラスと子クラスのメソッドの集合を考えてみると，子クラスは親クラスのメソッドをすべて持つわけですから，
</p>

<pre class="ref">
子クラスのメソッド集合 ⊇ 親クラスのメソッド集合
</pre>

<p>
という関係が成り立ちます．
</p>

<p>
次に，インタフェースを実装したクラスを考えてみましょう．ここでも
</p>

<pre class="ref">
インタフェースを実装したクラスのメソッド集合 ⊇ インタフェースのメソッド集合
</pre>

<p>
という関係が成り立ちます．
</p>

<p>
メソッドの集合の包含関係で考えると，クラスの継承とインタフェースの実装は似た関係があります．
</p>

<p>
例えば，
</p>

<pre class="ref">
class A extends B implements C, D {
  /* 省略 */
}
</pre>

<p>
というクラスがあったとすると，
</p>

<pre class="ref">
Aのメソッド集合 ⊇ Bのメソッド集合
Aのメソッド集合 ⊇ Cのメソッド集合
Aのメソッド集合 ⊇ Dのメソッド集合
</pre>

<p>
という関係があります．つまり，親クラスの<code>B</code>も，インタフェースの<code>C</code>，<code>D</code>も，どちらも<code>A</code>のメソッド集合の部分集合になっているという点は同じです．
</p>

<img src="hougan.png" width=600/>
<!--
<p>
それでは，親クラスのBとinterfaceのC，Dとの違いは何でしょうか．
<p>
interfaceのC，Dは，
そこで宣言されているメソッドと
同じ名前で同じ引数を持つメソッドが
Aにも存在するということを言っているだけです．
名前と引数の型が同じと言うことで，
メソッドの中身（本体）については，
何も言っていません．
<p>
一方，親クラスのBは，
そこで定義されているメソッドや変数と同じものを
Aも持っていると言っています．
こちらは，（再定義しない限り）
メソッドの中身も同じというわけです．
<p>
どんなメソッドがあるかということをそのクラスの「仕様」と呼ぶことにしましょう．
そのメソッドの中身がどうなっているかを「実装」，あるいは「実現」と
呼ぶことにしましょう．
<p>
そうすると，
<ul>
  <li>interfaceは仕様を決めているだけ．
  <li>親クラスは仕様だけでなく実装も決めている．
</ul>
ということになります．
<p>
あるクラスを作るときに，「implement ...」と書くと，
そのクラスの仕様を決めることになりますが，
実装までは決まりません．
実装は自分で書くことになります．
<p>
一方，あるクラスを作るときに，「extends ...」と書くと，
仕様はもちろんのこと，実装まで決めることになります．
再定義によって実装を変更することはありますが，
基本的な部分は親クラスの実装をそのまま使うことになります．
<p>
親クラスのものを全部継承して，
違う部分だけを再定義すればよいという継承の仕組みは，
非常に便利そうに見えたので，
一時期，何でもかんでも継承で書くという時代がありました．
<p>
ところが，
継承（extends）は，実装まで継承してしまうので，
interfaceに比べると，柔軟性がありません．
再利用性の高いプログラムを作ろうとすると，
この柔軟性のなさが問題になります．
<p>
最近の流れとしては，
<ul>
  <li>基本はinterfaceである．
  <li>実装まで継承しても構わない特別な場合（本当にis-a関係である時）には
      継承を使う．
</ul>
という考え方に移行しつつあります．
-->

<h3>代入</h3>

<p>
インタフェース型の変数にそのインタフェースを実装したクラスのオブジェクトを代入できるという話をして，<code>Photo</code>インタフェースの例を説明しました．継承関係でも同様に，親クラスの型の変数に子クラスのオブジェクトを代入することが可能です．
</p>

<p>
ある変数にあるオブジェクトを代入できるかどうかは，その変数の型(クラスあるいはインタフェース)のメソッド集合と，オブジェクトのメソッド集合の包含関係で決まります．例えば，
</p>

<pre class="ref">
Class1 x = new Class2();
</pre>

<p>
という文があったとしましょう．変数<code>x</code>は<code>Class1</code>の型なので，<code>Class1</code>のメソッドを呼び出す可能性があります．一方，実際に<code>x</code>に代入したオブジェクトのクラスは<code>Class2</code>です．ということは，
</p>

<pre class="ref">
Class2のメソッド集合 ⊇ Class1のメソッド集合
</pre>

<p>
というのが成り立っていないと，変数<code>x</code>を使ってメソッドを呼び出したときに，メソッドが存在しないという可能性が生じます．そこで，Javaのコンパイラは，
</p>

<pre class="ref">
Class2のメソッド集合 ⊇ Class1のメソッド集合
</pre>

<p>
が成り立つことが保証できない場合には，コンパイルエラーにします．
</p>

<p>
具体的には，
</p>

<pre class="ref">
Class2のメソッド集合 ⊇ Class1のメソッド集合
</pre>

<p>
が成立するかどうかは，継承とインタフェースを調べます．つまり，
</p>

<pre class="ref">
Foo x = new Class2();
</pre>

<p>
がエラーを発生しないのは，
</p>

<ul>
  <li><code>Foo</code>が，<code>Class2</code>かその祖先クラスの場合</li>
  <li><code>Foo</code>が，<code>Class2</code>の実装しているインタフェースの場合</li>
</ul>

<p>
になります．
</p>
<!--
<div class="rep">
<h1>練習問題10
&nbsp;&nbsp;
<INPUT type="button" value="解答提出" onClick="answer(2,10)" style="font-size:large;">
</h1>
次のプログラムの番号を付けた行のうち，
エラーが出るのはどの行でしょうか？
また，その理由を説明してください．

<pre class="ref">
interface I { }
class S { }
class C extends S implements I { }

class AssignTest {
    I i;
    S s;
    C c;
    void g1(I i) { }
    void g2(S s) { }
    void g3(C c) { }
    void f() {
        i = new I(); // 1
        s = new I(); // 2
        c = new I(); // 3
        i = new S(); // 4
        s = new S(); // 5
        c = new S(); // 6
        i = new C(); // 7
        s = new C(); // 8
        c = new C(); // 9
        g1(i); // 10
        g2(i); // 11
        g3(i); // 12
        g1(s); // 13
        g2(s); // 14
        g3(s); // 15
        g1(c); // 16
        g2(c); // 17
        g3(c); // 18
    }
}
</pre>
</div>
<p>今日はこれで終りです．
練習はパズルのような問題ばかりでしたが，
次回以降，GUIプログラミングでどのように「継承」「インタフェース」
が使われるのか，実例を示して説明する．
また，今日説明しきれなかった，オブジェクト指向の重要な概念の
「ポリモーフィズム」についても説明する予定です．
</p>
</div>

<HR>

<a name="hexdec"></a>
<div class="rep">
<h1>練習問題11 &nbsp; 16進，10進変換 (自由課題, 提出は任意)
&nbsp;&nbsp;
<INPUT type="button" value="解答提出" onClick="answer(2,11)" style="font-size:large;">
</h1><p>
まず，次のプログラムを実行してみてください．</p>
<pre class="ref">
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

class Radix extends JFrame implements ActionListener {
    private JFrame f;
    private JTextField hex,dec;
    private JLabel hexLabel,decLabel;
      
    public Radix() {
      hex = new JTextField(3);
      dec = new JTextField(3);
      this.setLayout(new GridLayout(2,2));
      this.add(new JLabel("16"));
      this.add(hex);
      this.add(new JLabel("10"));
      this.add(dec);
      this.pack();
      hex.addActionListener(this);
      dec.addActionListener(this);
      this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      this.setVisible(true);
    }

    public void actionPerformed(ActionEvent e){
      if (e.getSource()==hex)      {} // JTextFied hex に対する処理
      else if (e.getSource()==dec) {} // JTextFied dec に対する処理
    }
    public static void main(String[] args) {
      new Radix();
    }
}
</pre>
<p>
そうすると，左側に「16」，「10」と表示され，
右側に文字を入力する欄が表示されるはずです．</p>
<img src="radix.png"/>
<p>
左側の「16」，「10」は<a href="http://docs.oracle.com/javase/jp/1.5.0/api/javax/swing/JLabel.html">JLabel</a>で，コンストラクタで表示させる文字を指定します．
右側の文字を入力する欄は<a href="http://docs.oracle.com/javase/jp/1.5.0/api/javax/swing/JTextField.html">JTextField</a>で，コンストラクタで3文字分(最も幅の広い文字(大文字のW)の3文字分)の幅を指定しています．
上のプログラムでは，それぞれ2個ずつ作っています．
</p>
<p>
左側のJTextFieldに文字を入力してみてください．
入力できますね．
入力した文字を消したりというような編集もできるはずです．
JTextFieldは1行だけの文字入力を行なう部品です．
</p>

<p>
上のプログラムは，文字の入力はできますが，それ以外は何もできません．
</p>
<p>
このプログラムを改良して，
16の方の欄に16進数を入力してリターンキーを押すと，
10の方の欄に同じ数が10進数で表示され，
逆に，10の方の欄に10進数を入力してリターンキーを押すと，
16の方の欄に同じ数が16進数で表示されるプログラムを作ってください．
</p>
<p>
この改良のために必要になる知識をまとめてみます．
</p>
<ul>
  <li>JTextFieldは，文字を入力してリターンキーを押すと，
      Buttonと同様に，actionPerformedを呼び出すようになっています．
      従って，ActionListenerインターフェイスをimplementsしたクラスを作り，
      そのオブジェクトをJTextFieldにaddActionListenerで登録すれば，
      リターンキーを押した時の動作を書くことができます．
  <li>JTextFieldに入力した文字は，
<a href="http://docs.oracle.com/javase/jp/1.5.0/api/java/awt/TextComponent.html#getText()">getTextメソッド</a>
      で文字列(String)として取り出すことができます．
  <li>逆に文字列をJTextFieldにセットするには，
<a href="http://docs.oracle.com/javase/jp/1.5.0/api/java/awt/TextComponent.html#setText(java.lang.String)">setTextメソッド</a>
      を使います．
  <li>基数（16や10）を指定して文字列を数(int)に直すには，
<a href="http://docs.oracle.com/javase/jp/1.5.0/api/java/lang/Integer.html#parseInt(java.lang.String, int)">IntegerクラスのクラスメソッドparseInt</a>
      を使います．(n=Integer.parseInt("1a",16); のように使う)
  <li>逆に，基数を指定して数(int)を文字列に直すには，
<!--(変数)+"" &nbsp;- ->
<a href="http://docs.oracle.com/javase/jp/1.5.0/api/java/lang/Integer.html#toString(int, int)">IntegerクラスのクラスメソッドtoString</a>を使います．
(str=Integer.toString(26,16); のように使う)
</ul>
<p>
16進数の方のJTextFieldのリターンキーが押された時の動作は
次のようになります．
</p>
<ol>
  <li>16進数の JTextField から getText で16進数文字列を取り出す．
  <li>Integer.parseInt で基数16を指定して数に直す．
  <li>toString で基数10を指定して10進数の文字列に直す．
  <li>10進数の JTextField に setText で10進数の文字列をセットする．
</ol>
<p>
このヒントに基づいて，actionPerformedを完成させて下さい．
なお，actionPerformedは両方のJTextFieldから呼ばれるので，
メソッド内でどちらから呼ばれたか分からないと困ります．
そこで，以下のように 
actionPerformedの引数の
<a
href="http://docs.oracle.com/javase/jp/1.5.0/api/java/awt/event/ActionEvent.html">ActionEvent</a>
クラスの
<a href="http://docs.oracle.com/javase/jp/1.5.0/api/java/util/EventObject.html#getSource%28%29">
getSource</a> メソッドを用いることによって，呼び出し元のGUI部品を知ることができます．
こんな感じになります．</p>
<pre class="ref">
    public void actionPerformed(ActionEvent e){
      if (e.getSource()==hex)      {} // JTextFied hex に対する処理
      else if (e.getSource()==dec) {} // JTextFied dec に対する処理
    }
</pre>
<!--<p>
さて，ここで一つ問題が発生します．
上記の4ステップの1で，16進数のJTextFieldから文字列を取り出すためには，
16進数のJTextFieldオブジェクトがわからないと，
そのメソッドgetTextを呼び出すことができません．
同様に，上記の4ステップの4で，
10進数のJTextFieldに文字列をセットするためには，
10進数のJTextFieldオブジェクトがわからないと，
そのメソッドsetTextを呼び出すことができません．
</p>
<p>
そのためには，HexToDecConverterオブジェクトが，
16進数のJTextFieldオブジェクトと
10進数のJTextFieldオブジェクトを知っている必要があります．
これは，HexToDecConverterオブジェクトのインスタンス変数に
入れておくことで実現できます．
すなわち，
</p>
<ul>
  <li>16進数のJTextFieldオブジェクトと10進数のJTextFieldオブジェクトを
      入れるために，HexToDecConverterにインスタンス変数を二つ用意する．
  <li>HexToDecConverterをnewする時に，二つのJTextFieldオブジェクトを
      引数で渡す．
</ul>
<p>
というようにすれば解決します．
</p>
<p>
具体的には，こんな感じになるでしょう．
</p>
<pre class="ref">
class HexToDecConverter implements ActionListener {
  private JTextField hex;
  private JTextField dec;
  public HexToDecConverter(JTextField hex0,JTextField dec0) {
  // 省略
  }
  public void actionPerformed(ActionEvent e) {
  // 上記の4ステップを実行
  }
}
</pre>

<p>
10進数から16進数に変換するクラスDecToHexConverterも同様に作ることができます．
</p>
<p>
ところで，HexToDecConverterとDecToHexConverterは非常によく似ています．
うまく作ると，これは一つのクラスで済みます．
時間のある人は，これを一つのクラスにまとめてRadixConverterにしてください．
</p>- ->
</div>

<HR>
<div class="rep">
<h1>練習問題12 (自由課題，提出は任意)
&nbsp;&nbsp;
<INPUT type="button" value="解答提出" onClick="answer(2,12)" style="font-size:large;">
</h1>
<p>
今日の感想があれば書いて下さい．
理解が難しかった箇所などがあったら，書いてください．
</p>
</div>
-->

<hr/>
<i>電気通信大学 情報理工学部 情報・通信工学科 5学期 MICS実験第一 資料</i>
</body>
</html>
